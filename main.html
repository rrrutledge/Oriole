<h2>Introduction</h2>

<p>
  InnerSource is the strategy of applying open source practices and principles to internal software development.
  This strategy results in shared software that is responsive and nimble to the changing needs of its many internal consumers.
</p>

<p>
  This Oriole is an introduction to InnerSource.
  It teaches how to recognize situations that are good candidates for InnerSource.
  We'll outline at a high level how InnerSource can help in those situations.
  You'll become familiar with key terms used when discussing InnerSource.
  We'll also enumerate the key principles upon-which InnerSource is based and the benefits seen when it is applied effectively.
</p>

<h2>A Common Scenario</h2>

<p>
  Imagine two teams delivering separate pieces of software with one team's software depending on that of the other.
  An example could be an API service that depends on a shared library for part of its functionality.
  This type of situation is common in a large enterprise where a single team producing software may have dozens or hundreds of consumers.
  When consuming teams need many features, producing teams normally have some sort of requirements and prioritization process to decide which features they will work on.
  For feature requests that are not prioritized, the consuming team is faced with 3 choices, each of which come with their own drawbacks.
</p>

<ol>
  <li>
    <p>
      <strong>Wait it out</strong>.
      The consuming team may do nothing and limp along without the requested functionality.
      This option requires the least amount of work on their side.
      Depending on the benefit of the feature request, <em>Wait it out</em> might be just fine.
      However, waiting may come with real amounts of pain, especially if the requested functionalty is <em>never</em> delivered.
    </p>
  </li>
  <li>
    <p>
      <strong>Workaround</strong>.
      A consuming team that doesn't want to wait may do extra work somewhere else to compensate for the absence of their requested feature.
      This extra work may come as change in the consuming project.
      Alternatively, the consuming team may create a new project that meets their needs and replaces their use of all or part of the producing team's system (code/project duplication).
    </p>
    <p>
      This strategy allows the consuming team to get the requested feature via their own efforts only without direct dependency on others.
      It comes with several drawbacks, though.
    </p>
    <ol>
      <li>
        Any work done by the consuming team remains unavailable to any other consumers with the same feature request.
      </li>
      <li>
        The consuming team has inadvertently signed up for the long-term burden of maintaining the newly-written code, which is not in their core business domain.
      </li>
      <li>
        The company as-a-whole acquires duplicate projects and code in the same problem space.
      </li>
    </ol>
  </li>
  <li>
    <p>
      <strong>Escalate</strong>.  The consuming team may not take "no" for an answer and, instead, advocate to someone in the producers' management hierarchy to influence (or force) the producing team to do the work.
    </p>
    <p>
      This option sounds attractive for the consuming team because they get the requested feature without doing the work to implement or maintain it.
      It is still a drag on the team, though, because it necessarily diverts some of their attention and work to the non-productive task of escalation.
      Additionally, this option does not scale as there are so many times that a consumer can escalate feature requests before damaging their credibility.
    </p>
    <p>
      <em>Escalate</em> is similarly disruptive (even more so) for the producing team, who are taken out of their normal workflow and prioritization methods to deal with the escalated feature request.
    </p>
  </li>
</ol>

<h2>Solution Overview</h2>

<p>
  This strategy provides the wins of <em>Workaround</em> and <em>Escalate</em> without the same drawbacks to the teams and company.
</p>
<p>
  The basic idea of <em>InnerSource</em> is this: If a consuming team can't get what it needs by submitting a feature request then it may submit a pull request instead.
  The producing team partners to review and accept the pull request and the functionality it implements.
  In this context of a code submission, we call the consuming team the <strong>Guest</strong> team and the producing team the <strong>Host</strong> team.
</p>

<p>
    This option works well for the guest team because they get the functionality they need when they need it without taking on the long-term burden of maintenance of the solution.
    It works for the host team because they are able to better scale and serve their consumers.
    It works for the company at-large because solutions to shared problems end up in shared, centrally-maintained locations where anyone can use them. 
    More engineering time stays focused on producing code that solves company problems rather than the mechanics of the feature negotiation and escalation process.
</p>

<h2>Solution Detail</h2>

<p>
    Let's take a closer look at how the mechanics of the <em>InnerSource</em> process can work.
    To aid in this explanation, we'll name a few key individuals on the <strong>Guest</strong>
    and <strong>Host</strong> teams.
    First, the <strong>Product Owner</strong> determines what functionality the host team is willing to accept as contributions.
    The <strong>Contributor</strong> is the individual that submits the code contribution.
    The <strong>Trusted Committer</strong> provides any timely support and mentorship that the contributor needs to successfully submit the pull request.
</p>

<p>
  With those definitions, here is the basic outline of an InnerSource contribution.
</p>

<ul>
  <li>
    Guest team requests a feature from the host team.
  </li>
  <li>
    Product owner ensures that user stories representing the feature request are created.
    These stories should describe the requested feature in terms agreeable to the guest team.
    They also list any details from the host team on how the feature should be delivered in order for the work to be accepted.
    Examples of such details include architecture constraints, coding conventions, dependency usages, data contracts, etc.
  </li>
  <li>
    Supported by the trusted committer(s), the contributor submits the pull request(s) to implement the requested feature.
  </li>
</ul>

<p>
  Note that these steps do not assume a specific system for the general organization of a team's time or priorities.
  InnerSource assumes that teams already have existing such methods of organization and provides a framework of how to use them to work together where there is a guest team desiring to contribute code to a host.
</p>

<h2>
  Benefits
</h2>

<p>
  There are many benefits to collaborating via InnerSource.
  First and foremost, <strong>the guest team gets their feature</strong> request when they need it without the long-term burden of maintaining it.
  The company as-a-whole wins as the time of the guest team is put into <strong>code that others can use</strong>.
</p>

<p>
  While that result is the shining benefit of InnerSource, another result that's easy to overlook is the fact that <strong>the host team gets their feature, too</strong>.
  Recall that, as part of the InnerSource process, the product owner on the host team agrees from the outset that the requested feature is good and desirable.
  InnerSource allows the host team to receive help in creating a better product for its consumers!
</p>

<p>
  <strong>InnerSourcing provides the host team a scalable strategy</strong> for fulfilling the varying amounts of features requested from its many consumers.
  Given the fixed capacity of the full-time members of the host team, it's likely that at times the combined business roadmaps of their consumers will require very (or even unreasonably) large amounts of work to be done in the host team's product(s).
  Without InnerSource, this situation easily leads to a stressed, overworked team dealing with many feature requests escalated to its leaders.
</p>
<p>
  However, if the host team operates via InnerSource, the engineering resources required to build those features will appear in-proportion to their importance in the form of guest contributors.
  <strong>InnerSource becomes a force multiplier</strong> that allows a host team to temporarily act larger than its actual size during times of high demand.
  When the demand has ended, the team throughput scales back to normal levels, all without any micromanagement of team headcount or work items.
</p>

<p>
  Beyond the raw work that the host team is able to accomplish in its system, regular InnerSource contributions give the host team <strong>better requirements and prioritization alignment with all of its consumers</strong>.
  A host team can do its best requirements gathering on the work it produces, but when the consumer itself is the one submitting the work the chances are much higher that the resulting change is aligned to just what the consumer needs.
  While it may be only one single guest team submitting the change, that team is likely representative of many other consumers and their needs.
</p>

<p>
  In addition to this alignment, there is also a general training and education of contributors as the work with and learn from trusted committers.
  Having made a code contribution, they feel a stake in the host team project.
  It's something that they recommend to their colleagues or new teams that they join.
  They understand the project better and are able to answer questions about it to others, relieving the host team of some of that burden.
  This learning and cross-team alignment <strong>break down traditional company silos</strong>.
</p>

<h2>Principles</h2>

<p>
  Every company, team, project, and individual is different.
  Because of that fact, the exact way that the concept of InnerSource works will vary from one situation to another.
  At its core, however, are two principles that form the bedrock of any successful instance of InnerSource.
  These principles must be respected and present in order for InnerSource to achieve the benefits described earlier.
  The principles are:
</p>

<ul>
  <li>Voluntary Code Contribution</li>
  <li>Prioritized Mentorship</li>
</ul>

<p>
  Let's take a look at each of these principles in more detail.
</p>

<h3>Voluntary Code Contribution</h3>

<p>
  The first word <em>Voluntary</em> means that engagement in InnerSource from both the guest and host teams occurs of their own free will.
  The guest team voluntarily donates code to the host team and the host team voluntarily accepts it.
  This opt-in nature means that each team needs to be certain that their involvement adds value to the others' objectives.
  Never is a host team required to accept a contribution that isn't in ultimate alignment with their overall mission.
  Never is a guest team required to submit a contribution that doesn't ultimately further their own mission and priorities.
</p>

<p>
  The word <em>Code</em> emphasizes that the collaboration between guest and host goes all the way to the code.
  Guest involvement in opening issues, updating requirements, fixing docs, etc. is good, but collaboration needs to reach as far as submitting code to achieve all of the benefits that we've discussed.
</p>

<h3>Prioritized Mentorship</h3>

<p>
  <em>Mentorship</em> from host team to guest team is a key aspect of InnerSource.
  Contributors on guest teams are upleveled so that they understand enough about the host team system to change it successfully.
  In the process of doing so, they come to better understand the host team system as a general consumer.
  They can use it more effectively and help other consumers to do so as well. 
</p>

<p>
  It's critical that this mentorship for contributors is <em>Prioritized</em> by the host team.
  The team strives to make trusted committers available to mentor guest team contributors <em>at the time that they need it</em> as opposed to when it is convenient.
</p>


<h2>Conclusion</h2>

<p>
  In this Oriole, we've given an introduction to InnerSource.
  InnerSource applies open source best practices and principles to internal software development. 
  It gives an additional option to consumers when producing teams are not able to deliver a needed feature request.
  Successful InnerSource involves a <strong>product owner</strong> and <strong>trusted committer</strong> from the <strong>host team</strong> as well as a <strong>contributor</strong> from the <strong>guest team</strong>.
  Done effectively, InnerSource brings many benefits to both participating teams.
  They key principles upon-which effective InnerSource works are <strong>voluntary code contribution</strong> and <strong>prioritized mentorship</strong>.
</p>

<p>
  While this training contains a high-level overview of InnerSource, there are many more details useful in making InnerSource actually work for your team.
  If you want to join the ongoing conversation around InnerSource and its best practices, then join the <a href="http://www.innersourcecommons.org/">InnerSource Commons</a>.
  The commons sponsors a Slack channel, an InnerSource patterns working group, and multiple in-person summits each year.
  Participation in the commons is a great way to stay connected with the latest in InnerSource.
</p>
