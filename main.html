Where will we stop for feedback and assessment questions?

<h2>Introduction</h2>

<p>
    InnerSource is the methodology of applying open source practices and principles to internal software development.
    This methodology provides a low-friction method for ensuring that the features and functionality of shared projects are responsive and nimble to the changing needs of their many consumers.
</p>

<p>
    In this Oriole we'll define some key terms used when discussing InnerSource.
    We'll walk through the high-level mechanics of how InnerSourcing can work and enumerate the key principles upon-which these mechanics are based.
    Finally, we'll share other references that can help you deepen your understanding and craft of InnerSource.
</p>

<h2>Problem</h2>

<pre>
Producer and consumer.  Consumer wants a change, but for whatever reason it can't get in.
Consumer is left with rolling their own (workaround or system), waiting, or escalating.
A lot of innefficiency when this kind of situation happens at-scale throughout a large enterprise.
</pre>

<h2>Solution</h2>

<pre>
"Instead of a feature request, submit a pull request".
Go through that concept quickly.
There is a lot more to do to facilitate this happening.
Introduce the 5 key terms by referencing objects in the picture:
    * Host (team)
    * Guest (team)
    * Trusted Committer
    * Product Owner
    * Contributor
Go through the steps of a (basic) inner-source contribution
* (potentially) Ask made with request for functionality.
* (potentially) Product owner determines that this request is desirable to have in the product.
* (potentially) Feature request is de-prioritized.
* (potentially) Story outlining the work to enable the feature is created.
* Trusted committer is available to coach the contributor (as-needed).
    * Explain what the story representing the work means.
    * Give pointers/hints as to the sections of code that would need to change in order to implement.
    * Fast feedback during PR.
* Contributor does the work.
Here are the benefits:
* Guest team got their feature.
* Host team got their feature, too, and at less of a cost to them.  Remember that by-virtue of their accepting it and writing a story around it we know that it is something that they wanted to have and that is on their roadmap and vision.  The host team is getting help!
* Host team has a scalable mechanism for supporting guests.  Take away the wasted time of escalation and multiple rounds of alignment meetings.
* Grass-roots evangelism
* Better prioritization and requirements alignment.
* You were going to spend the time anyway on requirements alignment and escalation.  Just spend it actually getting some work done instead.
* Crowd-sourced support
Tell a success story of where these items have really worked.
* 5 teams at once building EC2 deployment together
* "We'd love to have some help with our stuff"
* Story of interrupt-driven work going from 65% to 5%.
</pre>

<h2>Explanation</h2>

<pre>

The idea of how people's time gets affected is orthoganal to InnerSource.  Use whatever scheduling you want alongside these principles of what you are working on.


2 main points:
* Voluntary Code Contribution
Engagement is voluntary on both sides.  The guest team voluntarily gives code and the host team voluntarily accepts it.  Both are advancing on their missions.
The host team should accept anything that meets the documented standard (feature requirements in the story and project requirements in CONTRIBUTING guidelines and CI system).  Rejection of code requirements for undocumented reasons will hurt your inner sourcing.  Part of what we're doing is building up more documentation.
How can you encourage contribution.

* Prioritized Mentorship
You have to write stories so that someone not on the team could work on them.
The mentorship aspect is important.
* Need to have the mentorship written down in the form of documentation.
"We will mentor anything without also including a link to the documentation."

The host team really needs to feel that their own success is in the impact on the guest teams as their project is used.
The amount of off-team interaction and contribution can be a success metric on its own.
Trusted committers can rotate.
Will spending time on trusted committership and product-owning inner-sourced contributions waste my time?
Do I really have to prioiritize the time of my trusted committers?

"InnerSource, at its heart, is a decision to make effective collaboration a priority. It is a commitment to doing the things that work in the long term, knowing that taking shortcuts end up being too expensive to repeat.
"

Summarize the main points of the training

I feel like we should mention The Apache Way somewhere.
</pre>

<h2>Conclusion</h2>

<pre>
We did InnerSourcing
You learned 5 key terms.
There are at least 3 more Orioles coming.
Join the conversation at InnerSource commons
</pre>


<hr />
<h1>!! BOILER PLATE TEXT BELOW !!</h1>
<hr />

<h1>A Simple Oriole</h1>
<p>A really simple example:</p>
<p>You can write paragraphs like this.</p>
<pre data-code-language="python" data-executable="true" data-type="programlisting">hey = &quot;hello world&quot;, 38+4
print(hey hello. This is an executable code block )!
</pre>
<div id="the-id">
<p>This is a block inside a div with an id the-id.
Very cool. Yes.</p>
</div>
<pre data-code-language="" >hey = &quot;hello world&quot;, 38+4
print(hey hello. This is a non executable block )!
</pre>
<div id="another-id">
<h2>More complicated example</h2>
</div>
<pre data-code-language="python" data-executable="true" data-type="programlisting">x = [1,1]
for i in range(12):
    x.append(x[-1] + x[-2]) 
print(', '.join(str(y) for y in x))
</pre>
<h2>A Chart</h2>
<div id="this-example">
</div>
<pre data-code-language="python" data-executable="true" data-type="programlisting">%matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
x = np.linspace(0, 3*np.pi, 500)
plt.plot(x, np.sin(x**2))
plt.title('A simple chirp');
</pre>
<h2>Seaborn Example</h2>
<pre data-code-language="python" data-executable="true" data-type="programlisting">from __future__ import print_function, division

%matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

x = np.linspace(0, 10, 1000)
plt.plot(x, np.sin(x), x, np.cos(x));

import seaborn as sns
sns.set()
plt.plot(x, np.sin(x), x, np.cos(x));
</pre>
<h2>Interactive widgets</h2>
<pre data-code-language="python" data-executable="true" data-type="programlisting">%matplotlib inline
from IPython.display import Image
from IPython.html.widgets import interact
from numpy import pi, cos, sin
import numpy as np
import pylab as plt
import seaborn as sns
sns.set()
</pre>
<pre data-code-language="pyt" data-executable="true" data-type="programlisting">def plot_fringe(bl_length, wavelength):
    &quot;&quot;&quot; Plot the fringe function for a baseline (see Fig 1)

    bl_length:      distance between antennas, in m
    wavelength:     wavelength, in m
    &quot;&quot;&quot;
    theta = np.linspace(-np.pi, np.pi, 401)
    l = sin(theta)
    F = cos(2 * pi * bl_length * l / wavelength)
    F2 = cos(2 * pi * 2 * bl_length * l / wavelength)

    plt.plot(l, F, c='#cc0000', label=&quot;Baseline 1-2&quot;)
    plt.plot(l, F2, c='#0000cc', label=&quot;Baseline 1-3&quot;)
    plt.xlabel(&quot;$sin(\\theta)$&quot;)
    plt.ylabel(&quot;Fringe amplitude&quot;)
    plt.ylim(-2, 2)
    plt.legend()

f = interact(plot_fringe, bl_length=(1, 100), wavelength=(1, 100))
&lt;/pre&gt;
</pre>
